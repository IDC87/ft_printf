 c = va_arg(args, int)
s = va_arg(args, char *)
d = va_arg(args, int)
i = va_arg(args, int)
u = va_arg(args, unsigned int)
p = va_arg(args, unsigned long)# or 
                               #(unsigned long)va_arg(args, void *);
x = va_arg(args, unsigned int)
X = va_arg(args, unsigned int)


    %d (print as a decimal integer)
    %6d (print as a decimal integer with a width of at least 6 wide)
    %f (print as a floating point)
    %4f (print as a floating point with a width of at least 4 wide)
    %.4f (print as a floating point with a precision of four characters after the decimal point)
    %3.2f (print as a floating point at least 3 wide and a precision of 2)



%[flags][width][.precision]type 
*/

//int serie_if(const char *string, int i, arg_list(arg))


/* ft_x
if (string[i - 1] == 'c')
            {
                char c = va_arg(arg, int);
                write (1, &c, 1);
            }
ft_count
funcao()
    int x;
    ft_x();
    ft_count()
    return (x);
100/10;
100/16
string[i]
    i++;
writes;
countar;
x += numero
return (x); 

  - Store the remainder when the number is divided by 16 in a temporary variable temp. If temp is less than 10, insert (48 + temp) in a character array otherwise if temp is greater than or equals to 10, insert (55 + temp) in the character array.
      Divide the number by 16 now
    - Repeat the above two steps until the number is not equal to 0.
    - Print the array in reverse order now.


    COISAS QUE FALTAM

    // nao esquecer de criar a condicao para caso a string acabe em % (na funcao do ft_printf)
    /*relembrar por causa do free(num)*/ nas funcoes dos unsigneds